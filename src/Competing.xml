<templateSet group="Competing">
  <template name="RotateArray" value="inline fun &lt;reified T&gt;Array&lt;Array&lt;T&gt;&gt;.rotate()= Array(this[0].size){ i-&gt;Array(this.size){ j-&gt;this[j][i]} }&#10;fun Array&lt;CharArray&gt;.rotate()= Array(this[0].size){ i-&gt;CharArray(this.size){ j-&gt;this[j][i]} }&#10;fun Array&lt;IntArray&gt;.rotate()= Array(this[0].size){ i-&gt;IntArray(this.size){ j-&gt;this[j][i]} }&#10;fun Array&lt;LongArray&gt;.rotate()= Array(this[0].size){ i-&gt;LongArray(this.size){ j-&gt;this[j][i]} }&#10;fun Array&lt;DoubleArray&gt;.rotate()= Array(this[0].size){ i-&gt;DoubleArray(this.size){ j-&gt;this[j][i]} }&#10;&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="MergeSort" value="private fun mergeSort(list: List&lt;Int&gt;): List&lt;Int&gt; {&#10;    fun merge(left: List&lt;Int&gt;, right: List&lt;Int&gt;): List&lt;Int&gt;  {&#10;        var indexLeft = 0&#10;        var indexRight = 0&#10;        val newList : MutableList&lt;Int&gt; = mutableListOf()&#10;        while (indexLeft &lt; left.count() &amp;&amp; indexRight &lt; right.count()) {&#10;            if (left[indexLeft] &lt;= right[indexRight]) {&#10;                newList.add(left[indexLeft])&#10;                indexLeft++&#10;            } else {&#10;                newList.add(right[indexRight])&#10;                indexRight++&#10;            }&#10;        }&#10;        while (indexLeft &lt; left.size) {&#10;            newList.add(left[indexLeft])&#10;            indexLeft++&#10;        }&#10;        while (indexRight &lt; right.size) {&#10;            newList.add(right[indexRight])&#10;            indexRight++&#10;        }&#10;        return newList&#10;    }&#10;    if (list.size &lt;= 1) {&#10;        return list&#10;    }&#10;    val middle = list.size / 2&#10;    val left = list.subList(0,middle)&#10;    val right = list.subList(middle,list.size)&#10;    return merge(mergeSort(left), mergeSort(right))&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="FirstSearch" value="private fun dfs(size: Int, adjacencyList: List&lt;List&lt;Int&gt;&gt;, v: Int = 0) {&#10;    val searchOrder = ArrayList&lt;Int&gt;()&#10;    val parent = IntArray(size) { -1 }&#10;    val isVisited = BooleanArray(size)&#10;    fun dfs(v: Int) {&#10;        searchOrder.add(v)&#10;        isVisited[v] = true&#10;        adjacencyList[v].forEach { e -&gt;&#10;            if (!isVisited[e]) {&#10;                parent[e] = v&#10;                dfs(e)&#10;            }&#10;        }&#10;    }&#10;    // Recursively search&#10;    dfs(v)&#10;}&#10;&#10;private fun bfs(size: Int, adjacencyList: List&lt;List&lt;Int&gt;&gt;, v: Int = 0) {&#10;    val searchOrder: MutableList&lt;Int&gt; = ArrayList()&#10;    val parent = IntArray(size) { -1 } // Initialize parent[i] to -1&#10;    val queue = LinkedList&lt;Int&gt;() // list used as a queue&#10;    val isVisited = BooleanArray(size)&#10;    queue.offer(v) // Enqueue v&#10;    isVisited[v] = true // Mark it visited&#10;    while (!queue.isEmpty()) {&#10;        val u = queue.poll() // Dequeue to u&#10;        searchOrder.add(u) // u searched&#10;        adjacencyList[u].forEach { e -&gt; // Note that e.u is u&#10;            if (!isVisited[e]) { // e.v is w in Listing 28.11&#10;                queue.offer(e) // Enqueue w&#10;                parent[e] = u // The parent of w is u&#10;                isVisited[e] = true // Mark w visited&#10;            }&#10;        }&#10;    }&#10;&#10;}&#10;&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="ShoretestPath" value="private fun dijkstra(size: Int, adjacencyList: List&lt;List&lt;List&lt;Int&gt;&gt;&gt;, startingVertex: Int = 0) {&#10;    val cost = DoubleArray(size) { Double.POSITIVE_INFINITY }&#10;    cost[startingVertex] = 0.0 // Cost of source is 0&#10;    val parent = IntArray(size) // Parent of a vertex&#10;    parent[startingVertex] = -1 // startingVertex is the root&#10;    val processed = BooleanArray(size)&#10;    val t = PriorityQueue&lt;Pair&lt;Double, Int&gt;&gt;(Comparator.comparing { it.first })&#10;    val list = ArrayList&lt;Int&gt;()&#10;    t.add(Pair(0.0, startingVertex))&#10;    while (!t.isEmpty()) {&#10;        val a = t.poll().second&#10;        if (processed[a]) continue&#10;        processed[a] = true&#10;        list.add(a)&#10;        for (u in adjacencyList[a]) {&#10;            val b = u[1]&#10;            val w = u[2]&#10;            if (cost[a] + w &lt; cost[b]) {&#10;                parent[b] = a&#10;                cost[b] = cost[a] + w&#10;                t.add(Pair(cost[b], b))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun floydWarshall(adjacencyMatrix: Array&lt;DoubleArray&gt;): Array&lt;DoubleArray&gt; {&#10;    val distance = adjacencyMatrix&#10;    val size = distance.size&#10;    for (k in 0 until size) {&#10;        for (i in 0 until size) {&#10;            for (j in 0 until size) {&#10;                distance[i][j] = java.lang.Double.min(distance[i][j], distance[i][k] + distance[k][j])&#10;            }&#10;        }&#10;    }&#10;&#10;    return distance&#10;}&#10;&#10;private fun bellmanFord(graph: Array&lt;IntArray&gt;, V: Int, E: Int, src: Int) {&#10;    val dis = IntArray(V) { Int.MAX_VALUE }&#10;    dis[src] = 0&#10;    for (i in 0 until V - 1) {&#10;        for (j in 0 until E) {&#10;            if (dis[graph[j][0]] != Int.MAX_VALUE &amp;&amp; dis[graph[j][0]] + graph[j][2] &lt;&#10;                dis[graph[j][1]]&#10;            ) dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2]&#10;        }&#10;    }&#10;    for (i in 0 until E) {&#10;        val x = graph[i][0]&#10;        val y = graph[i][1]&#10;        val weight = graph[i][2]&#10;        if (dis[x] != Int.MAX_VALUE &amp;&amp; dis[x] + weight &lt; dis[y]) println(&quot;Graph contains negative weight cycle&quot;)&#10;    }&#10;&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="MinimumSpanningTree" value="private fun prim(size: Int, adjacencyList: List&lt;List&lt;List&lt;Int&gt;&gt;&gt;, startingVertex: Int = 0) {&#10;    val cost = DoubleArray(size) { Double.POSITIVE_INFINITY }&#10;    cost[startingVertex] = 0.0 // Cost of source is 0&#10;    val parent = IntArray(size) // Parent of a vertex&#10;    parent[startingVertex] = -1 // startingVertex is the root&#10;    val t = mutableSetOf&lt;Int&gt;()&#10;    while (t.size &lt; size) {&#10;        var u = -1 // Vertex to be determined&#10;        var currentMinCost = Double.POSITIVE_INFINITY&#10;        for (i in 0 until size) {&#10;            if (!t.contains(i) &amp;&amp; cost[i] &lt; currentMinCost) {&#10;                currentMinCost = cost[i]&#10;                u = i&#10;            }&#10;        }&#10;        if (u == -1) break else t.add(u)&#10;        for (e in adjacencyList[u]) {&#10;            val sum = cost[u]&#10;            if (!t.contains(e[1]) &amp;&amp; cost[e[1]] &gt; sum) {&#10;                cost[e[1]] = sum&#10;                parent[e[1]] = u&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun kruskal(size: Int, edges: List&lt;List&lt;Int&gt;&gt;) {&#10;    edges.sortedBy { it[2] }&#10;    /* Arrays.sort(edges, Comparator.comparing { e: IntArray -&gt;&#10;         e[2]&#10;     })*/&#10;&#10;    fun getSet(i: Int, parent: IntArray): Int =&#10;        if (parent[i] == i) i else getSet(parent[i], parent).also { parent[i] = it }&#10;&#10;    fun unionSets(i: Int, j: Int, ranks: IntArray, parent: IntArray): Boolean {&#10;        val ii = getSet(i, parent)&#10;        val jj = getSet(j, parent)&#10;        if (ii != jj) {&#10;            if (ranks[ii] &gt; ranks[jj]) {&#10;                parent[jj] = ii&#10;            } else if (ranks[jj] &gt; ranks[ii]) {&#10;                parent[ii] = jj&#10;            } else {&#10;                parent[ii] = jj&#10;                ranks[jj]++&#10;            }&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    val rank = IntArray(size)&#10;    val parent = IntArray(size)&#10;    for (i in 1 until size) {&#10;        parent[i] = i&#10;    }&#10;    var cost = 0&#10;    val pairs = HashSet&lt;List&lt;Int&gt;&gt;()&#10;    for (e in edges) {&#10;        if (unionSets(e[0], e[1], rank, parent)) {&#10;            pairs.add(e)&#10;            cost += e[2]&#10;        }&#10;    }&#10;&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="Primes" value="private fun Int.gcd(b: Int): Int {&#10;    return if (b == 0) this else b.gcd(this % b)&#10;}&#10;private fun Long.gcd(b: Long): Long {&#10;    return if (b == 0L) this else b.gcd(this % b)&#10;}&#10;private fun Int.isPrime(): Boolean {&#10;    if (this &lt; 2) return false&#10;    var x = 2&#10;    while (x * x &lt;= this) {&#10;        if (this % x == 0) return false&#10;        x++&#10;    }&#10;    return true&#10;}&#10;&#10;private fun Int.primeFactors(): LinkedList&lt;Int&gt; {&#10;    var n = this&#10;    val f = LinkedList&lt;Int&gt;()&#10;    var x = 2&#10;    while (x * x &lt;= n) {&#10;        while (n % x == 0) {&#10;            f.addLast(x)&#10;            n /= x&#10;        }&#10;        x++&#10;    }&#10;    if (n &gt; 1) f.addLast(n)&#10;    return f&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="Permutations" value="private fun permutationsIteration(n:Int,m:Int=n,f:(LinkedList&lt;out Int&gt;)-&gt;Unit){&#10;    val list= LinkedList&lt;Int&gt;()&#10;    var count=0&#10;    val visited=BooleanArray(n)&#10;&#10;    fun getPerm(i:Int=0){&#10;        if (i==m){&#10;            f(list)&#10;            count++&#10;            return&#10;        }&#10;        for (j in 0 until n){&#10;            if (visited[j])&#10;                continue&#10;            list.add(j)&#10;            visited[j]=true&#10;            getPerm(i+1)&#10;            visited[j]=false&#10;            list.removeLast()&#10;        }&#10;    }&#10;&#10;    getPerm()&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="Combinations" value="private fun combinationsIteration(n:Int, m:Int, f:(LinkedList&lt;out Int&gt;)-&gt;Unit){&#10;    val list= LinkedList&lt;Int&gt;()&#10;    var count=0&#10;&#10;    fun getCombination(i:Int=0,lastVal:Int=0){&#10;        if (i==m){&#10;            f(list)&#10;            count++&#10;            return&#10;        }&#10;        for (j in lastVal until n){&#10;            list.add(j)&#10;            getCombination(i+1,j+1)&#10;            list.removeLast()&#10;        }&#10;    }&#10;    getCombination()&#10;}&#10;&#10;private fun getCombinationCountArray(n:Int,m:Int){&#10;    require(n&gt;=m)&#10;    val arr=Array(m+1){LongArray(n+1)}&#10;    for (i in 0 until m+1)&#10;        for (j in 0 until n+1)&#10;            arr[i][j]=when{&#10;                j==0-&gt;1&#10;                i==0-&gt;0&#10;                else-&gt; arr[i-1][j-1]+arr[i-1][j]&#10;            }&#10;&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="BinarySearchTechs" value="private fun BSfindFirst(start: Int, end: Int, x: Int,f:(Int)-&gt;Int): Int {&#10;    var s = start&#10;    var e = end&#10;    while (s &lt; e) {&#10;        val mid = s + (e - s) / 2&#10;        if (f(mid) &lt; x) s = mid + 1&#10;        else if (f(mid) &gt; x) e = mid - 1&#10;        else e = mid&#10;    }&#10;    return s&#10;}&#10;&#10;private fun BSfindLast(start: Int, end: Int, x: Int,f:(Int)-&gt;Int): Int {&#10;    var s = start&#10;    var e = end&#10;    while (s &lt; e) {&#10;        val mid = s + (e - s) / 2&#10;        if (f(mid) &lt; x) s = mid + 1&#10;        else if (f(mid) &gt; x) e = mid - 1&#10;        else s = mid&#10;    }&#10;    return s&#10;}&#10;&#10;private fun binary( start:Double, end:Double,can:(Double)-&gt;Boolean):Double{&#10;    var s=start&#10;    var e=end&#10;    repeat(100){&#10;        val mid = (s + e) / 2&#10;        if (can(mid)) e = mid else s = mid&#10;    }&#10;&#10;    if( can(e) )&#10;        return s&#10;&#10;    return -1.0&#9;// failed&#10;}&#10;&#10;private fun BSfindFirstTrue(start: Int, end: Int, f:(Int)-&gt;Boolean): Int {&#10;    var s = start&#10;    var e = end&#10;    while (s &lt; e) {&#10;        val mid = s + (e - s) / 2&#10;        if (f(mid)) e = mid&#10;        else s = mid+1&#10;    }&#10;    return s&#10;}&#10;&#10;private fun BSfindLastFalse(start: Int, end: Int, f:(Int)-&gt;Boolean): Int {&#10;    var s = start&#10;    var e = end&#10;    while (s &lt; e) {&#10;        val mid = s + (e - s) / 2&#10;        if (f(mid)) e = mid-1&#10;        else s = mid&#10;    }&#10;    return s&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="ComplexAndGeometry" value="private fun isEven(i: Int) = i % 2 == 0&#10;private val img = Complex(0.0, 1.0)&#10;private fun abs(c: Complex): Double = c.abs()&#10;private fun exp(c: Complex): Complex {&#10;    val e = exp(c.real)&#10;    return Complex(e * cos(c.img), e * sin(c.img))&#10;}&#10;private fun sinh(c: Complex) = (exp(c) - exp(-c)) / 2&#10;private fun cosh(c: Complex) = (exp(c) + exp(-c)) / 2&#10;private fun tanh(c: Complex) = sinh(c) / cosh(c)&#10;private fun coth(c: Complex) = cosh(c) / sinh(c)&#10;private fun cos(c: Complex) = (exp(img * c) + exp(-img * c)) / 2.0&#10;private fun sin(c: Complex) = img * (exp(-img * c) - exp(img * c)) / 2.0&#10;private fun tan(c: Complex) = sin(c) / cos(c)&#10;private fun cot(c: Complex) = cos(c) / sin(c)&#10;private fun sec(c: Complex) = Complex.ONE / cos(c)&#10;private fun ln(c: Complex) = Complex(ln(c.abs()), c.phase())&#10;private fun roots(n: Int) =&#10;    (1 ..n).map { exp(img*2*PI*it/n) }&#10;private operator fun Number.plus(c: Complex) = Complex(this.toDouble() + c.real, c.img)&#10;private operator fun Number.minus(c: Complex) = Complex(this.toDouble() - c.real, -c.img)&#10;private operator fun Number.times(c: Complex) = Complex(this.toDouble() * c.real, this.toDouble() * c.img)&#10;private operator fun Number.div(c: Complex) = Complex.ONE / c&#10;private class Complex(val real: Double, val img: Double) {&#10;    constructor(real: Number, img: Number) : this(real.toDouble(), img.toDouble())&#10;    override fun equals(other: Any?): Boolean {&#10;        return (other is Complex &amp;&amp; real == other.real &amp;&amp; img == other.img)&#10;    }&#10;    override fun hashCode(): Int {&#10;        return real.hashCode() * 31 + img.hashCode()&#10;    }&#10;    operator fun unaryMinus() = Complex(-real, -img)&#10;    operator fun plus(c: Complex) = Complex(real + c.real, img + c.img)&#10;    operator fun plus(n: Number) = Complex(real + n.toDouble(), img)&#10;    operator fun minus(c: Complex) = Complex(real - c.real, img - c.img)&#10;    operator fun minus(n: Number) = Complex(real - n.toDouble(), img)&#10;    operator fun times(c: Complex) = Complex(real * c.real - img * c.img, real * c.img + img * c.real)&#10;    operator fun times(n: Number) = Complex(n.toDouble() * real, n.toDouble() * img)&#10;    operator fun div(n: Number) = Complex(real / n.toDouble(), img / n.toDouble())&#10;    operator fun div(c: Complex): Complex {&#10;        val den = c.normSquared()&#10;        if (isPracticallyZero(den)) {&#10;            return this / 0 //TO make this consistent with division by zero number&#10;        }&#10;        val num = this * c.conjugate()&#10;        return num / den&#10;    }&#10;    operator fun component1() = real&#10;    operator fun component2() = img&#10;    /**&#10;     * Complex conjugate = x-y*i&#10;     */&#10;    fun conjugate() = Complex(real, -img)&#10;    fun normSquared() = real * real + img * img&#10;    fun abs(): Double = sqrt(this.normSquared())&#10;    fun phase(): Double = atan(img / real)&#10;    fun pow(a: Double) = exp(ln(this) * a)&#10;    fun pow(a: Number) = exp(ln(this) * a)&#10;    fun pow(a: Complex) = exp(ln(this) * a)&#10;    override fun toString(): String {&#10;        return when {&#10;            isPracticallyZero(img) -&gt; &quot;${ real}&quot;&#10;            isPracticallyZero(real) -&gt; &quot;${ img}i&quot;&#10;            img &lt; 0 -&gt; &quot;${ real}-${ -img}i&quot;&#10;            else -&gt; &quot;${ real}+${ img}i&quot;&#10;        }&#10;    }&#10;    private fun isPracticallyZero(d: Double) = abs(d) &lt; DEFAULT_TOLERANCE&#10;    companion object {&#10;        /**&#10;         * Complex 0 = 0 + 0i&#10;         */&#10;        val ZERO = Complex(0.0, 0.0)&#10;        /**&#10;         * Complex 1 = 1 + 0i&#10;         */&#10;        val ONE = Complex(1.0, 0.0)&#10;        const val DEFAULT_TOLERANCE = 1.0E-15&#10;        fun fromNumber(n: Number) = Complex(n.toDouble(), 0.0)&#10;        fun fromPolar(radius: Double, theta: Double) :Complex  =radius*exp(img*theta)&#10;    }&#10;    /**&#10;     * Tests if the norm of the complex number is smaller than the given tolerance&#10;     */&#10;    fun isZero(tolerance: Double) = this.abs() &lt; tolerance&#10;    infix fun to(exponent: Int): Complex {&#10;        if (exponent == 0) {&#10;            return ONE&#10;        }&#10;        if (exponent == 1) {&#10;            return this&#10;        }&#10;        val half = to(exponent / 2)&#10;        return if (isEven(exponent)) {&#10;            half * half&#10;        } else {&#10;            half * half * this&#10;        }&#10;    }&#10;    infix fun to(exponent: Complex) = this.pow(exponent)&#10;    infix fun to(exponent: Number) = this.pow(exponent)&#10;}&#10;*/&#10;&#10;//Point2D&#10;/*&#10;val Complex.X&#10;    get() = this.real&#10;val Complex.Y&#10;    get() = this.img&#10;fun Complex.angle()=this.phase()&#10;fun vec(A:Complex,B:Complex)=B-A&#10;fun dotProduct(A:Complex,B:Complex)=(A.conjugate()*B).real&#10;fun crossProduct(A:Complex,B:Complex)=(A.conjugate()*B).img&#10;fun Complex.length()=this.abs()&#10;fun Complex.normalize()=this/this.abs()&#10;fun rotateAroundO(p:Complex,ang:Double)=p* exp(ang*img)&#10;fun rotateAroundA(p:Complex,ang:Double,about:Complex)=rotateAroundO(vec(about,p),ang)+about&#10;fun reflectO(v:Complex,m:Complex)=(((v)/(m)).conjugate()*(m))&#10;fun reflect(p:Complex, p0:Complex, p1:Complex):Complex {&#10;    val z = p-p0&#10;    val w = p1-p0&#10;    return (z/w).conjugate()*w + p0 // Refelect point p1 around p0p1&#10;}&#10;fun fixAngle(A:Double): Double =if(A &gt; 1) 1.0 else if (A &lt; -1) -1.0 else A&#10;fun angleO( a:Complex, O:Complex, b:Complex):Complex {&#10;    val v1=(a - O)&#10;    val v2=(b - O)&#10;    return Complex.fromPolar(1.0, acos(fixAngle ( dotProduct(v1, v2) / v1.length() / v2.length() )) )&#10;}&#10;fun getAng(a:Complex, b:Complex, c:Complex):Double {&#10;    var ang =  vec(b, c).angle() -  vec(b, a).angle()&#10;    if(ang&lt; 0)&#10;        ang+=2*PI&#10;    return ang&#10;}&#10; */&#10;&#10;//lines&#10;&#10;/*&#10;&#10;fun isCollinear(a: Complex, b: Complex, c: Complex): Boolean {&#10;    return (crossProduct(b - a, c - a)).isZero()&#10;}&#10;&#10;fun isPointOnRay(p0: Complex, p1: Complex, p2: Complex): Boolean {&#10;    return if ((p2 - p0).length().isZero()) true else ((p1 - p0).normalize()== (p2 - p0).normalize())&#10;}&#10;&#10;fun isPointOnSegment(a: Complex, b: Complex, c: Complex): Boolean {&#10;    return isPointOnRay(a, b, c) &amp;&amp; isPointOnRay(b, a, c)&#10;}&#10;fun distToLine(p0: Complex, p1: Complex, p2: Complex): Double {&#10;    return abs(crossProduct(p1 - p0, p2 - p0) / (p0 - p1).length()) // area = 0.5*b*h&#10;}&#10;&#10;fun distToSegment(p0: Complex, p1: Complex, p2: Complex): Double {&#10;    var d1: Double&#10;    var d2: Double&#10;    val v1: Complex = p1 - p0&#10;    val v2: Complex = p2 - p0&#10;    if (dotProduct(v1, v2).also { d1 = it } &lt;= 0) return (p2 - p0).length()&#10;    if (dotProduct(v1, v1).also { d2 = it } &lt;= d1) return (p2 - p1).length()&#10;    val t = d1 / d2&#10;    return (p2 - (p0 + v1 * t)).length()&#10;}&#10;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
</templateSet>